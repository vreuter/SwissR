# fs-utils.R
# Author: Vince Reuter
# email: vince.reuter@gmail.com


#' Path expansion utility
#'
#' \code{ExpandPath} takes a path and expands user/environment variables.
#' \code{NULL}, \code{NA}, and empty path inputs are returned as-is. For 
#' environment variables, the assumption is that each will be prefixed with 
#' a dollar-sign \code{$}.
#'
#' @param path The filesystem path to expand.
#' @return Input path with user/environment variables expanded.
#' @export
ExpandPath = function(path) {

  # Handle null/empty input.
  if (is.null(path) | is.na(path) | identical("", path)) { return(path) }

  # Helper functions
  chopPath = function(p) { 
    if (p == dirname(p)) p else c(chopPath(dirname(p)), basename(p)) }
  expand = function(pathPart) { 
    if (startsWith(pathPart, "$")) {
      system(sprintf("echo %s", pathPart), intern = TRUE)
    } else { pathPart }
  }

  # Split path; short-circuit return or ensure no reference to this folder.
  parts = chopPath(path)
  if (length(parts) < 2) { return(parts) }
  if (identical(".", parts[1])) { parts = parts[2:length(parts)] }

  # Expand any environment variables and return the complete path.
  fullPath = do.call(file.path, lapply(parts, expand))
  return(fullPath)
}


#' Builder of path to epilog output file within project's results folder.
#'
#' \code{MakeFilePath} uses information about file paths from a project 
#' configuration object, in conjunction with a sample name and how to 
#' deal with subfolder(s), to create a path to the output file that's 
#' known to the project for the sample indicated by \code{sampleName}, and 
#' that corresponds to a particular type/format (e.g., as generated by a 
#' particular pipeline).
#'
#' @param base Project configuration object (environment- or list-like), from  
#'             which the parent folder is derived. Alternatively, an actual 
#'             path to a parent folder.
#' @param sampleName Name for the sample for which to create filepath.
#' @param subdir What to assume about the project's folder structure. If a 
#'               Boolean value, this indicates whether the expectation is for 
#'               the file to live within a results subfolder named with the 
#'               \code{sampleName}. If a string, this indicates the actual
#'               name of the subfolder within the project's results folder. 
#'               If a function, it should accept \code{sampleName} and the 
#'               derive a name for the appropriate subfolder that way.
#' @param suffix Text to place between the sample name and the extension.
#'               The default is no suffix, which will also result from an 
#'               argument that's empty, \code{NULL}, or \code{FALSE}.
#' @return Path expected for file for the project defined by \code{base} and 
#'              the sample indicated by \code{sampleName}. The correspondence 
#'              with file type/format is captured by the \code{subdir} and 
#'              \code{extension} specifications.
#' @export
MakeFilePath = function(base, sampleName, subdir, extension, suffix = NULL) {

  # Use sample name as filename base, possibly with suffix.
  nameBase = sampleName
  if (is.character(suffix)) { nameBase = paste0(nameBase, suffix) }

  # Filename can be constructed right awawy since it doesn't depend on any 
  # of the logic regarding input type for base or subdir.
  filename = sprintf("%s.%s", nameBase, extension)
  
  # Allow base to be raw text or a project config (named/nested list).
  if (!is.character(base)) { base = base$metadata$results_subdir }

  # Allow Boolean or callable argument to subdir parameter (rather than text).
  if(is.logical(subdir)) {
    # Omit subdir if it's toggled off; otherwise, use sample name.
    if (!subdir) { return(file.path(base, filename)) }
    subdir = sampleName
  } else if (is.function(subdir)) { subdir = subdir(sampleName) }
  
  return(file.path(base, subdir, filename))
}
